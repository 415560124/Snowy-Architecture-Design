# 框架介绍

参考小诺框架官网及文档：

[项目介绍]: ./README.md	"项目介绍"

# 项目结构讲解

## snowy-cloud

- snowy-common == 基础通用模块
- snowy-plugin == 插件包
  - snowy-plugin-auth == 登录鉴权插件
  - snowy-plugin-biz == 业务功能插件
  - snowy-plugin-client == C端功能插件
  - snowy-plugin-dev == 开发工具插件
  - snowy-plugin-gen == 代码生成插件
  - snowy-plugin-mobile == 移动端管理插件
  - snowy-plugin-sys == 系统功能插件
    - snowy-plugin-sys-api == 系统功能API接口包
    - snowy-plugin-sys-api-context == 系统功能API调用实现包2
    - snowy-plugin-sys-feign == 系统功能feign接口包
    - snowy-plugin-sys-feign-provider == 系统功能服务内feign接口实现包
    - snowy-plugin-sys-func == 系统功能
      - src
        - main
          - java
            - vip.xiaonuo.sys == 模块包
              - core
                - config == 模块配置包
                  - xxx == 模块其他包，如enums枚举包、util工具包、listener监听器包等
              - modular
                - user == 功能包
                  - controller == 控制器包
                  - entity == 实体包
                  - mapper == mapper包
                    - mapping == mapping包
                  - param == 参数包
                  - provider == api实现包
                  - result == 结果集包
                  - service == service包
                    - impl == service实现类包
  - snowy-plugin-a == A模块功能插件
    - snowy-plugin-sys-api == A模块功能API接口包
    - snowy-plugin-sys-api-context == A模块功能API调用实现包2
    - snowy-plugin-sys-feign == A模块功能feign接口包
    - snowy-plugin-sys-feign-provider == A模块功能服务内feign接口实现包
    - snowy-plugin-sys-func == A模块功能
- snowy-modules == 启动模块
  - snowy-web-app == 主启动模块
  - snowy-biz-app == 业务服务主启动模块
  - snowy-a-app == A服务主启动模块（示例）
- snowy-server == 中间件服务
  - snowy-actuator-app == 监控服务
  - snowy-gateway-app == 网关服务
  - snowy-nacos-app == 注册中心/配置中心
  - snowy-sentinel-app == 限流服务
  - snowy-xxl-job-app == 分布式调度服务

# 插件介绍

## 1. 插件架构概述

`snowy-plugin-sys` 模块采用分层架构设计，包含5个核心子模块：

```
snowy-plugin-sys/
├── snowy-plugin-sys-api/           
# API接口定义层
├── snowy-plugin-sys-api-context/   
# API上下文实现层  
├── snowy-plugin-sys-feign/         
# Feign客户端接口层
├── snowy-plugin-sys-feign-provider/
# Feign服务提供方实现层
└── snowy-plugin-sys-func/          
# 核心业务功能实现层
```

## 2. 子模块详细分析

### 2.1 snowy-plugin-sys-api模块

功能定位 ：定义系统功能的API接口规范

核心接口 ：

- `SysApi` ：系统基础功能接口
- `SysUserApi` ：用户管理接口
- `SysRoleApi` ：角色管理接口
- `SysMenuApi` ：菜单管理接口
- `SysOrgApi` ：组织管理接口

设计特点 ：

- 采用接口分离原则，按业务领域划分接口
- 提供标准化的API契约定义
- 支持微服务间的松耦合调用

### 2.2 snowy-plugin-sys-api-context模块

功能定位 ：为API接口提供上下文实现，作为微服务调用的适配层

核心实现类 ：

- `SysUserApiContextBean` ：用户API上下文实现
- SysRoleApiContextBean：角色API上下文实现
- SysApiContextBean：系统API上下文实现

实现机制 ：

- 实现对应的API接口
- 通过Feign客户端调用远程服务
- 提供本地缓存和异常处理

### 2.3 snowy-plugin-sys-feign模块

功能定位 ：定义微服务间调用的Feign客户端接口

核心Feign接口 ：

- `SysUserFeign` ：用户服务Feign接口
- `SysFeign` ：系统服务Feign接口

### 2.4 snowy-plugin-sys-feign-provider模块

功能定位 ：提供Feign接口的具体实现，暴露HTTP端点

核心Provider类 ：

- `SysUserFeignProvider` ：用户服务提供方实现
- `SysFeignProvider` ：系统服务提供方实现


实现方式 ：

- 实现对应的Feign接口
- 委托给具体的API实现类
- 提供RESTful HTTP端点

### 2.5 snowy-plugin-sys-func模块

功能定位 ：核心业务功能实现层，包含完整的业务逻辑

模块结构 ：

```
snowy-plugin-sys-func/
├── modular/
│   ├── user/     # 用户管理
│   ├── role/     # 角色管理
│   ├── org/      # 组织管理
│   ├── position/ # 职位管理
│   ├── resource/ # 资源管理
│   ├── relation/ # 关系管理
│   └── group/    # 分组管理
└── core/         # 核心工具类
```

核心Service实现 ：

- `SysUserServiceImpl` ：用户管理业务实现
- `SysRoleServiceImpl` ：角色管理业务实现

## 3. 模块间集成方式和依赖关系

### 3.1 依赖关系图

```
snowy-biz-app
    ↓ (依赖)
snowy-plugin-sys-api
    ↑ (实现)
snowy-plugin-sys-api-context
    ↓ (调用)
snowy-plugin-sys-feign
    ↑ (实现)
snowy-plugin-sys-feign-provider
    ↓ (依赖)
snowy-web-app
```

### 3.2 Maven依赖配置

snowy-web-app的依赖配置 ：

```
<!-- 系统功能插件 -->
<dependency>
    <groupId>vip.xiaonuo</groupId>
    <artifactId>snowy-plugin-sys-func</artifactId>
</dependency>	

<!-- snowy-plugin-sys-feign-provider，向外暴露feign接口实现 -->
<dependency>
    <groupId>vip.xiaonuo</groupId>
    <artifactId>snowy-plugin-sys-feign-provider</artifactId>
</dependency>
```

snowy-biz-app的依赖配置 ：

```
<!-- 系统功能插件Feign接口 -->
<dependency>
    <groupId>vip.xiaonuo</groupId>
    <artifactId>snowy-plugin-sys-feign</artifactId>
</dependency>

<!-- 系统功能插件Api接口context -->
<dependency>
    <groupId>vip.xiaonuo</groupId>
    <artifactId>snowy-plugin-sys-api-context</artifactId>
</dependency>
```

## 4. 调用流程和时序图

### 4.1 跨服务调用流程

```
业务应用(snowy-biz-app)
    ↓ 1. 注入SysUserApi
SysUserApiContextBean
    ↓ 2. 调用SysUserFeign
SysUserFeign (Feign客户端)
    ↓ 3. HTTP调用
SysUserFeignProvider (snowy-web-app)
    ↓ 4. 委托调用
SysUserApi实现
    ↓ 5. 业务处理
SysUserServiceImpl
```

### 4.2 本地调用流程

```
Controller层
    ↓ 1. 注入Service
SysUserServiceImpl
    ↓ 2. 业务逻辑处理
Mapper层 (MyBatis-Plus)
    ↓ 3. 数据库操作
Database
```

## 5. 接口调用规范和参数传递机制

### 5.1 接口调用规范

1. API接口规范 ：

- 所有API接口继承统一的基础接口
- 使用标准的参数对象(Param)和返回对象(Result)
- 支持分页查询和批量操作

2. Feign接口规范 ：

- 使用 @FeignClient 注解标识服务名称
- 使用标准的HTTP方法注解( @GetMapping , @PostMapping 等)
- 支持请求参数绑定和响应体解析

3. 参数传递机制 ：

- 简单参数：直接传递基本类型
- 复杂参数：使用专门的Param对象封装
- 批量操作：使用List集合传递

### 5.2 示例代码

```
// API接口定义
public interface SysUserApi {
    SysUser getUserByIdWithoutException(String id);
    List<SysUser> getUserListByIdListWithoutException(List<String> idList);
}

// Feign接口定义
@FeignClient(name = "snowy-web-app", contextId = "sysUserFeign")
public interface SysUserFeign {
    @GetMapping("/feign/sys/user/getUserByIdWithoutException")
    SysUser getUserByIdWithoutException(@RequestParam("id") String id);
}
```

## 6. 异常处理机制

### 6.1 异常处理层次

1. 全局异常处理 ：

- `GlobalExceptionUtil.java` ：统一异常处理工具
- 支持多种异常类型的分类处理
- 返回标准化的错误响应格式

2. 业务异常处理 ：

- CommonException ：通用业务异常
- 自定义错误码和错误消息
- 支持异常链传递

### 6.2 异常处理示例

```
public static CommonResult<String> getCommonResult(Exception e) {
    if (e instanceof CommonException commonException) {
        // 通用业务异常，直接返回给前端
        return CommonResult.get(commonException.getCode(),commonException.getMsg(), null);
    } else {
        // 未知异常返回服务器异常
        log.error(">>> 服务器未知异常，具体信息：", e);
        return CommonResult.error("服务器异常");
    }
}
```

## 7. 总结

Snowy-Cloud的 `snowy-plugin-sys` 模块采用了分层架构设计：

优势 ：

1. 模块化设计 ：清晰的职责分离，便于维护和扩展

2. 微服务支持 ：通过Feign实现服务间的松耦合调用

3. 标准化接口 ：统一的API规范和调用方式

4. 异常处理 ：完善的异常处理机制和错误响应

5. 可扩展性 ：插件化架构支持功能模块的灵活组合

# 飞行计划审核审批系统 - （Activiti + LiteFlow）设计与实现

## 1. 整体架构设计

将系统分为三层：**表现层**、**业务逻辑层**和**数据持久层**。Activiti 和 LiteFlow 都位于业务逻辑层。

- **表现层 (UI/API)**:
  - 用户界面：供用户提交飞行计划、查看审核状态、处理待办审核任务。
  - API 接口：供前端调用，触发流程、提交任务、查询状态。
- **业务逻辑层 (Service Layer)**:
  - **流程编排引擎 (Activiti)**:
    - **职责**: 管理宏观流程。定义流程的起点、终点、主要阶段和任务节点。负责流程的 “骨架” 和任务的生命周期。
    - **核心对象**: `ProcessEngine`, `RuntimeService`, `TaskService`, `RepositoryService`。
  - **规则引擎 (LiteFlow)**:
    - **职责**: 执行动态逻辑。在流程的关键节点，被 Activiti 调用，负责计算，即根据业务规则动态决定下一步。
    - **核心对象**: `FlowExecutor`, 组件 (`Node`), 规则文件 (`flow.xml`)。
  - **业务服务 (Business Service)**:
    - **职责**: 处理具体的业务操作，如保存飞行计划数据、调用外部接口上报审批等。它是 Activiti 和 LiteFlow 都可以调用的原子服务。
- **数据持久层 (Data Layer)**:
  - **Activiti 数据库**: Activiti 自带的一套表结构，用于存储流程定义、流程实例、任务、变量等。

**架构交互图**:

```plaintext
┌───────────────┐
│   表现层       │  (用户/前端)
│  UI / API     │
└───────┬───────┘
        ▼
┌─────────────────────────────────────────────┐
│           业务逻辑层                          │
│  ┌─────────────┐      ┌─────────────────┐   │
│  │  Activiti   │      │   LiteFlow      │   │
│  │ (工作流引擎)  │◄────►│ (规则引擎)       │   │
│  └───────┬─────┘      └────────┬────────┘   │
│          │                     │             │
│          ▼                     ▼             │
│  ┌─────────────────────────────────────────┐ │
│  │       业务服务 (Business Service)        │ │
│  └─────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
        ▲
        │
┌───────┴───────┐
│   数据层       │
│  (DB, Cache)  │
└───────────────┘
```

## 2. Activiti 流程设计 (BPMN 模型)

使用 BPMN 2.0 来定义主流程。以下是一个简化的流程定义 (`flightPlanProcess.bpmn20.xml`)：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<bpmn2:definitions ... id="Definitions_1" targetNamespace="http://activiti.org/bpmn">
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <!-- ... 图形化定义 ... -->
  </bpmndi:BPMNDiagram>
  <bpmn2:process id="flightPlanProcess" isExecutable="true">
    <!-- 1. 开始事件 -->
    <bpmn2:startEvent id="StartEvent_1" />
    <bpmn2:sequenceFlow id="Flow_1" sourceRef="StartEvent_1" targetRef="Gateway_NeedReview" />

    <!-- 2. 判断是否需要审核 (排他网关) -->
    <bpmn2:exclusiveGateway id="Gateway_NeedReview" default="Flow_SkipReview" />
    
    <!-- 2a. 需要审核的路径 -->
    <bpmn2:sequenceFlow id="Flow_NeedReview" sourceRef="Gateway_NeedReview" targetRef="ServiceTask_GetReviewers">
      <bpmn2:conditionExpression xsi:type="bpmn2:tFormalExpression">${needReview == true}</bpmn2:conditionExpression>
    </bpmn2:sequenceFlow>

    <!-- 3. 调用 LiteFlow 获取审核单位列表 (服务任务) -->
    <bpmn2:serviceTask id="ServiceTask_GetReviewers" name="获取审核单位"
                       activiti:delegateExpression="${getReviewersDelegate}" />
    <bpmn2:sequenceFlow id="Flow_2" sourceRef="ServiceTask_GetReviewers" targetRef="UserTask_Review" />

    <!-- 4. 审核任务 (多实例任务) -->
    <bpmn2:userTask id="UserTask_Review" name="平台审核"
                    activiti:candidateUsers="${reviewers}"
                    activiti:assignee="${reviewer}">
      <!-- 多实例配置 elementVariable为循环集合的变量名-->
      <bpmn2:multiInstanceLoopCharacteristics isSequential="false" activiti:collection="${reviewUnitsList}" activiti:elementVariable="reviewUnit">
         <!-- nrOfInstances 实例总数 ，nrOfActiveInstances 当前还没有完成的实例 , nrOfCompleteInstances 已经完成的实例个数 -->
        <bpmn2:completionCondition>${nrOfCompletedInstances >= nrOfInstances}</bpmn2:completionCondition>
      </bpmn2:multiInstanceLoopCharacteristics>
    </bpmn2:userTask>
    <bpmn2:sequenceFlow id="Flow_3" sourceRef="UserTask_Review" targetRef="ServiceTask_SubmitApproval" />

    <!-- 2b. 跳过审核的路径 -->
    <bpmn2:sequenceFlow id="Flow_SkipReview" sourceRef="Gateway_NeedReview" targetRef="ServiceTask_SubmitApproval" />

    <!-- 5. 上报上级审批 (服务任务) -->
    <bpmn2:serviceTask id="ServiceTask_SubmitApproval" name="上报上级审批"
                       activiti:delegateExpression="${submitApprovalDelegate}" />
    <bpmn2:sequenceFlow id="Flow_4" sourceRef="ServiceTask_SubmitApproval" targetRef="EndEvent_1" />

    <!-- 6. 结束事件(继续扩展) -->
    <bpmn2:endEvent id="EndEvent_1" />
  </bpmn2:process>
</bpmn2:definitions>
```

**BPMN 关键节点说明**:

- **`Gateway_NeedReview` (排他网关)**: 判断是否需要审核。`needReview` 变量的值可以在流程启动时传入，或通过一个前置的服务任务计算得出。
- **`ServiceTask_GetReviewers` (服务任务)**: 这是与 LiteFlow 集成的关键点。
  - `activiti:delegateExpression="${getReviewersDelegate}"` 指定了一个 Java Delegate Bean。
  - 这个 Delegate 的 `execute` 方法会调用 LiteFlow 引擎。
- **`UserTask_Review` (用户任务)**:
  - **多实例 (`multiInstanceLoopCharacteristics`)**: `isSequential="false"` 表示并行审核。`activiti:collection="${reviewUnitsList}"` 会从流程变量中获取一个列表（如 `["unit1", "unit2"]`），并为列表中的每一项创建一个任务实例。
  - `completionCondition` 定义了多实例任务何时完成。`${nrOfCompletedInstances >= nrOfInstances}` 表示所有审核单位都完成后，该节点才算通过。

## 3. LiteFlow 规则与组件设计

LiteFlow 负责实现 `ServiceTask_GetReviewers` 中调用的动态逻辑。

**步骤 1: 定义 LiteFlow 组件 (Java Code)**

```java
// 获取审核单位列表的组件
@Component("getReviewUnits")
public class GetReviewUnitsNode extends NodeComponent {
    @Autowired
    private ReviewUnitService reviewUnitService;

    @Override
    public void process() {
        // 1. 从流程上下文获取参数
        FlightPlanContext context = this.getFirstContextBean();
        String flightArea = context.getFlightArea();
        String flightType = context.getFlightType();

        // 2. 执行业务逻辑，从数据库或规则引擎获取审核单位
        List<String> reviewUnitIds = reviewUnitService.findReviewUnitsByAreaAndType(flightArea, flightType);

        // 3. 将结果放入上下文，供后续节点使用
        context.setReviewUnitIds(reviewUnitIds);
    }
}
```

**步骤 2: 定义 LiteFlow 规则 (`flow.xml`)**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<flow>
    <!-- 定义一个流程，用于获取审核单位 -->
    <chain name="getReviewersChain">
        THEN(getReviewUnits);
    </chain>
</flow>
```

这个例子很简单，如果逻辑更复杂（例如，先根据区域筛选，再根据任务类型过滤），可以用 `THEN`, `WHEN` 等关键字编排多个组件。

## 4. Activiti 与 LiteFlow 集成实现

**步骤 1: 实现 Java Delegate**，获取审核单位

```java
@Component("getReviewersDelegate")
public class GetReviewersDelegate implements JavaDelegate {

    @Autowired
    private FlowExecutor flowExecutor;

    @Override
    public void execute(DelegateExecution execution) {
        // 1. 从 Activiti 获取业务数据
        String planId = execution.getProcessBusinessKey();
        FlightPlan plan = flightPlanService.getById(planId);

        // 2. 准备 LiteFlow 的上下文
        LiteflowResponse response = flowExecutor.execute2Resp("getReviewersChain", plan);

        // 3. 从 LiteFlow 结果中获取数据
        if (response.isSuccess()) {
            FlightPlanContext context = response.getFirstContextBean();
            List<String> reviewUnitIds = context.getReviewUnitIds();

            // 4. 将结果设置回 Activiti 的流程变量中
            // 注意：多实例任务需要一个列表变量
            execution.setVariable("reviewUnitsList", reviewUnitIds);
            
            // 也可以直接设置候选人
            // execution.setVariable("reviewers", String.join(",", reviewUnitIds));
        } else {
            // 处理异常
            throw new BpmnError("LITEFLOW_ERROR", "获取审核单位失败: " + response.getMessage());
        }
    }
}
```

**步骤 2: 启动流程**

业务服务中，当用户提交飞行计划时，启动 Activiti 流程。

```java
@Service
public class FlightPlanServiceImpl implements FlightPlanService {
    @Autowired
    private RuntimeService runtimeService;

    public void submitFlightPlan(FlightPlan plan) {
        // 保存飞行计划数据
        this.save(plan);

        // 设置流程变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("needReview", true); // 或者根据规则动态判断

        // 启动流程实例，businessKey 关联业务数据
        runtimeService.startProcessInstanceByKey("flightPlanProcess", plan.getId(), variables);
    }
}
```

**步骤 3: 处理用户任务**

当 Activiti 流程到达 `UserTask_Review` 节点时，会创建任务。前端通过 `TaskService` 查询待办任务。用户完成审核后，调用 `taskService.complete(taskId, variables)` 来完成任务并推进流程。

## 5. 总结与流程示例

1. **用户提交**: 用户在 UI 上提交飞行计划，保存数据并调用启动 Activiti 流程。
2. **Activiti 流转**: 流程到达 `ServiceTask_GetReviewers`。
3. **Delegate 调用 LiteFlow**: `GetReviewersDelegate` 的 `execute` 方法被触发，它调用 LiteFlow 的 `getReviewersChain`。
4. **LiteFlow 执行**: `GetReviewUnitsNode` 根据飞行计划区域和类型，从数据库查询出需要审核的单位列表（如 `["unit-A-id", "unit-B-id"]`）。
5. **结果返回 Activiti**: LiteFlow 将列表返回给 Delegate，Delegate 通过 `execution.setVariable("reviewUnitsList", ...)` 将其设置为流程变量。
6. **创建审核任务**: Activiti 进入 `UserTask_Review` 多实例节点。它发现 `reviewUnitsList` 变量，于是为 "unit-A-id" 和 "unit-B-id" 各创建一个待办审核任务。
7. **用户审核**: 审核员 A 和 B 登录系统，看到各自的待办任务，填写意见并提交。
8. **流程继续**: 当最后一个审核员（比如 B）完成任务后，`completionCondition` 满足，`UserTask_Review` 节点结束。
9. **上报审批**: 流程流转到 `ServiceTask_SubmitApproval`，调用相应的 Delegate 将计划上报给上级平台。
10. **流程结束**: 上报完成后，流程到达 `EndEvent`，整个飞行计划审核审批流程结束。
